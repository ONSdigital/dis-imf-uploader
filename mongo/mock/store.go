// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"context"
	"github.com/ONSdigital/dis-imf-uploader/models"
	"github.com/ONSdigital/dis-imf-uploader/mongo"
	"sync"
)

// Ensure, that StoreMock does implement mongo.Store.
// If this is not the case, regenerate this file with moq.
var _ mongo.Store = &StoreMock{}

// StoreMock is a mock implementation of mongo.Store.
//
//	func TestSomethingThatUsesStore(t *testing.T) {
//
//		// make and configure a mocked mongo.Store
//		mockedStore := &StoreMock{
//			CloseFunc: func() error {
//				panic("mock out the Close method")
//			},
//			CreateUploadFunc: func(ctx context.Context, upload *models.Upload) error {
//				panic("mock out the CreateUpload method")
//			},
//			GetPendingUploadsFunc: func(ctx context.Context) ([]*models.Upload, error) {
//				panic("mock out the GetPendingUploads method")
//			},
//			GetUploadFunc: func(ctx context.Context, id string) (*models.Upload, error) {
//				panic("mock out the GetUpload method")
//			},
//			HealthCheckFunc: func(ctx context.Context) error {
//				panic("mock out the HealthCheck method")
//			},
//			ListAuditLogsFunc: func(ctx context.Context, uploadID string, action string, userEmail string, page int, pageSize int) ([]*models.AuditLog, int64, error) {
//				panic("mock out the ListAuditLogs method")
//			},
//			ListUploadsFunc: func(ctx context.Context, status string, page int, pageSize int, sortBy string, sortDir string) ([]*models.Upload, int64, error) {
//				panic("mock out the ListUploads method")
//			},
//			LogAuditFunc: func(ctx context.Context, log *models.AuditLog) error {
//				panic("mock out the LogAudit method")
//			},
//			SaveBackupMetadataFunc: func(ctx context.Context, meta *models.BackupMetadata) error {
//				panic("mock out the SaveBackupMetadata method")
//			},
//			UpdateCloudFrontStatusFunc: func(ctx context.Context, id string, status string) error {
//				panic("mock out the UpdateCloudFrontStatus method")
//			},
//			UpdateUploadApprovedFunc: func(ctx context.Context, id string, reviewedBy string, s3Key string, backupKey string, invID string) error {
//				panic("mock out the UpdateUploadApproved method")
//			},
//			UpdateUploadRejectedFunc: func(ctx context.Context, id string, reviewedBy string, reason string) error {
//				panic("mock out the UpdateUploadRejected method")
//			},
//		}
//
//		// use mockedStore in code that requires mongo.Store
//		// and then make assertions.
//
//	}
type StoreMock struct {
	// CloseFunc mocks the Close method.
	CloseFunc func() error

	// CreateUploadFunc mocks the CreateUpload method.
	CreateUploadFunc func(ctx context.Context, upload *models.Upload) error

	// GetPendingUploadsFunc mocks the GetPendingUploads method.
	GetPendingUploadsFunc func(ctx context.Context) ([]*models.Upload, error)

	// GetUploadFunc mocks the GetUpload method.
	GetUploadFunc func(ctx context.Context, id string) (*models.Upload, error)

	// HealthCheckFunc mocks the HealthCheck method.
	HealthCheckFunc func(ctx context.Context) error

	// ListAuditLogsFunc mocks the ListAuditLogs method.
	ListAuditLogsFunc func(ctx context.Context, uploadID string, action string, userEmail string, page int, pageSize int) ([]*models.AuditLog, int64, error)

	// ListUploadsFunc mocks the ListUploads method.
	ListUploadsFunc func(ctx context.Context, status string, page int, pageSize int, sortBy string, sortDir string) ([]*models.Upload, int64, error)

	// LogAuditFunc mocks the LogAudit method.
	LogAuditFunc func(ctx context.Context, log *models.AuditLog) error

	// SaveBackupMetadataFunc mocks the SaveBackupMetadata method.
	SaveBackupMetadataFunc func(ctx context.Context, meta *models.BackupMetadata) error

	// UpdateCloudFrontStatusFunc mocks the UpdateCloudFrontStatus method.
	UpdateCloudFrontStatusFunc func(ctx context.Context, id string, status string) error

	// UpdateUploadApprovedFunc mocks the UpdateUploadApproved method.
	UpdateUploadApprovedFunc func(ctx context.Context, id string, reviewedBy string, s3Key string, backupKey string, invID string) error

	// UpdateUploadRejectedFunc mocks the UpdateUploadRejected method.
	UpdateUploadRejectedFunc func(ctx context.Context, id string, reviewedBy string, reason string) error

	// calls tracks calls to the methods.
	calls struct {
		// Close holds details about calls to the Close method.
		Close []struct {
		}
		// CreateUpload holds details about calls to the CreateUpload method.
		CreateUpload []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Upload is the upload argument value.
			Upload *models.Upload
		}
		// GetPendingUploads holds details about calls to the GetPendingUploads method.
		GetPendingUploads []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// GetUpload holds details about calls to the GetUpload method.
		GetUpload []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID string
		}
		// HealthCheck holds details about calls to the HealthCheck method.
		HealthCheck []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ListAuditLogs holds details about calls to the ListAuditLogs method.
		ListAuditLogs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UploadID is the uploadID argument value.
			UploadID string
			// Action is the action argument value.
			Action string
			// UserEmail is the userEmail argument value.
			UserEmail string
			// Page is the page argument value.
			Page int
			// PageSize is the pageSize argument value.
			PageSize int
		}
		// ListUploads holds details about calls to the ListUploads method.
		ListUploads []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Status is the status argument value.
			Status string
			// Page is the page argument value.
			Page int
			// PageSize is the pageSize argument value.
			PageSize int
			// SortBy is the sortBy argument value.
			SortBy string
			// SortDir is the sortDir argument value.
			SortDir string
		}
		// LogAudit holds details about calls to the LogAudit method.
		LogAudit []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Log is the log argument value.
			Log *models.AuditLog
		}
		// SaveBackupMetadata holds details about calls to the SaveBackupMetadata method.
		SaveBackupMetadata []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Meta is the meta argument value.
			Meta *models.BackupMetadata
		}
		// UpdateCloudFrontStatus holds details about calls to the UpdateCloudFrontStatus method.
		UpdateCloudFrontStatus []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID string
			// Status is the status argument value.
			Status string
		}
		// UpdateUploadApproved holds details about calls to the UpdateUploadApproved method.
		UpdateUploadApproved []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID string
			// ReviewedBy is the reviewedBy argument value.
			ReviewedBy string
			// S3Key is the s3Key argument value.
			S3Key string
			// BackupKey is the backupKey argument value.
			BackupKey string
			// InvID is the invID argument value.
			InvID string
		}
		// UpdateUploadRejected holds details about calls to the UpdateUploadRejected method.
		UpdateUploadRejected []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID string
			// ReviewedBy is the reviewedBy argument value.
			ReviewedBy string
			// Reason is the reason argument value.
			Reason string
		}
	}
	lockClose                  sync.RWMutex
	lockCreateUpload           sync.RWMutex
	lockGetPendingUploads      sync.RWMutex
	lockGetUpload              sync.RWMutex
	lockHealthCheck            sync.RWMutex
	lockListAuditLogs          sync.RWMutex
	lockListUploads            sync.RWMutex
	lockLogAudit               sync.RWMutex
	lockSaveBackupMetadata     sync.RWMutex
	lockUpdateCloudFrontStatus sync.RWMutex
	lockUpdateUploadApproved   sync.RWMutex
	lockUpdateUploadRejected   sync.RWMutex
}

// Close calls CloseFunc.
func (mock *StoreMock) Close() error {
	if mock.CloseFunc == nil {
		panic("StoreMock.CloseFunc: method is nil but Store.Close was just called")
	}
	callInfo := struct {
	}{}
	mock.lockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	mock.lockClose.Unlock()
	return mock.CloseFunc()
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//
//	len(mockedStore.CloseCalls())
func (mock *StoreMock) CloseCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockClose.RLock()
	calls = mock.calls.Close
	mock.lockClose.RUnlock()
	return calls
}

// CreateUpload calls CreateUploadFunc.
func (mock *StoreMock) CreateUpload(ctx context.Context, upload *models.Upload) error {
	if mock.CreateUploadFunc == nil {
		panic("StoreMock.CreateUploadFunc: method is nil but Store.CreateUpload was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Upload *models.Upload
	}{
		Ctx:    ctx,
		Upload: upload,
	}
	mock.lockCreateUpload.Lock()
	mock.calls.CreateUpload = append(mock.calls.CreateUpload, callInfo)
	mock.lockCreateUpload.Unlock()
	return mock.CreateUploadFunc(ctx, upload)
}

// CreateUploadCalls gets all the calls that were made to CreateUpload.
// Check the length with:
//
//	len(mockedStore.CreateUploadCalls())
func (mock *StoreMock) CreateUploadCalls() []struct {
	Ctx    context.Context
	Upload *models.Upload
} {
	var calls []struct {
		Ctx    context.Context
		Upload *models.Upload
	}
	mock.lockCreateUpload.RLock()
	calls = mock.calls.CreateUpload
	mock.lockCreateUpload.RUnlock()
	return calls
}

// GetPendingUploads calls GetPendingUploadsFunc.
func (mock *StoreMock) GetPendingUploads(ctx context.Context) ([]*models.Upload, error) {
	if mock.GetPendingUploadsFunc == nil {
		panic("StoreMock.GetPendingUploadsFunc: method is nil but Store.GetPendingUploads was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetPendingUploads.Lock()
	mock.calls.GetPendingUploads = append(mock.calls.GetPendingUploads, callInfo)
	mock.lockGetPendingUploads.Unlock()
	return mock.GetPendingUploadsFunc(ctx)
}

// GetPendingUploadsCalls gets all the calls that were made to GetPendingUploads.
// Check the length with:
//
//	len(mockedStore.GetPendingUploadsCalls())
func (mock *StoreMock) GetPendingUploadsCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockGetPendingUploads.RLock()
	calls = mock.calls.GetPendingUploads
	mock.lockGetPendingUploads.RUnlock()
	return calls
}

// GetUpload calls GetUploadFunc.
func (mock *StoreMock) GetUpload(ctx context.Context, id string) (*models.Upload, error) {
	if mock.GetUploadFunc == nil {
		panic("StoreMock.GetUploadFunc: method is nil but Store.GetUpload was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  string
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGetUpload.Lock()
	mock.calls.GetUpload = append(mock.calls.GetUpload, callInfo)
	mock.lockGetUpload.Unlock()
	return mock.GetUploadFunc(ctx, id)
}

// GetUploadCalls gets all the calls that were made to GetUpload.
// Check the length with:
//
//	len(mockedStore.GetUploadCalls())
func (mock *StoreMock) GetUploadCalls() []struct {
	Ctx context.Context
	ID  string
} {
	var calls []struct {
		Ctx context.Context
		ID  string
	}
	mock.lockGetUpload.RLock()
	calls = mock.calls.GetUpload
	mock.lockGetUpload.RUnlock()
	return calls
}

// HealthCheck calls HealthCheckFunc.
func (mock *StoreMock) HealthCheck(ctx context.Context) error {
	if mock.HealthCheckFunc == nil {
		panic("StoreMock.HealthCheckFunc: method is nil but Store.HealthCheck was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockHealthCheck.Lock()
	mock.calls.HealthCheck = append(mock.calls.HealthCheck, callInfo)
	mock.lockHealthCheck.Unlock()
	return mock.HealthCheckFunc(ctx)
}

// HealthCheckCalls gets all the calls that were made to HealthCheck.
// Check the length with:
//
//	len(mockedStore.HealthCheckCalls())
func (mock *StoreMock) HealthCheckCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockHealthCheck.RLock()
	calls = mock.calls.HealthCheck
	mock.lockHealthCheck.RUnlock()
	return calls
}

// ListAuditLogs calls ListAuditLogsFunc.
func (mock *StoreMock) ListAuditLogs(ctx context.Context, uploadID string, action string, userEmail string, page int, pageSize int) ([]*models.AuditLog, int64, error) {
	if mock.ListAuditLogsFunc == nil {
		panic("StoreMock.ListAuditLogsFunc: method is nil but Store.ListAuditLogs was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		UploadID  string
		Action    string
		UserEmail string
		Page      int
		PageSize  int
	}{
		Ctx:       ctx,
		UploadID:  uploadID,
		Action:    action,
		UserEmail: userEmail,
		Page:      page,
		PageSize:  pageSize,
	}
	mock.lockListAuditLogs.Lock()
	mock.calls.ListAuditLogs = append(mock.calls.ListAuditLogs, callInfo)
	mock.lockListAuditLogs.Unlock()
	return mock.ListAuditLogsFunc(ctx, uploadID, action, userEmail, page, pageSize)
}

// ListAuditLogsCalls gets all the calls that were made to ListAuditLogs.
// Check the length with:
//
//	len(mockedStore.ListAuditLogsCalls())
func (mock *StoreMock) ListAuditLogsCalls() []struct {
	Ctx       context.Context
	UploadID  string
	Action    string
	UserEmail string
	Page      int
	PageSize  int
} {
	var calls []struct {
		Ctx       context.Context
		UploadID  string
		Action    string
		UserEmail string
		Page      int
		PageSize  int
	}
	mock.lockListAuditLogs.RLock()
	calls = mock.calls.ListAuditLogs
	mock.lockListAuditLogs.RUnlock()
	return calls
}

// ListUploads calls ListUploadsFunc.
func (mock *StoreMock) ListUploads(ctx context.Context, status string, page int, pageSize int, sortBy string, sortDir string) ([]*models.Upload, int64, error) {
	if mock.ListUploadsFunc == nil {
		panic("StoreMock.ListUploadsFunc: method is nil but Store.ListUploads was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Status   string
		Page     int
		PageSize int
		SortBy   string
		SortDir  string
	}{
		Ctx:      ctx,
		Status:   status,
		Page:     page,
		PageSize: pageSize,
		SortBy:   sortBy,
		SortDir:  sortDir,
	}
	mock.lockListUploads.Lock()
	mock.calls.ListUploads = append(mock.calls.ListUploads, callInfo)
	mock.lockListUploads.Unlock()
	return mock.ListUploadsFunc(ctx, status, page, pageSize, sortBy, sortDir)
}

// ListUploadsCalls gets all the calls that were made to ListUploads.
// Check the length with:
//
//	len(mockedStore.ListUploadsCalls())
func (mock *StoreMock) ListUploadsCalls() []struct {
	Ctx      context.Context
	Status   string
	Page     int
	PageSize int
	SortBy   string
	SortDir  string
} {
	var calls []struct {
		Ctx      context.Context
		Status   string
		Page     int
		PageSize int
		SortBy   string
		SortDir  string
	}
	mock.lockListUploads.RLock()
	calls = mock.calls.ListUploads
	mock.lockListUploads.RUnlock()
	return calls
}

// LogAudit calls LogAuditFunc.
func (mock *StoreMock) LogAudit(ctx context.Context, log *models.AuditLog) error {
	if mock.LogAuditFunc == nil {
		panic("StoreMock.LogAuditFunc: method is nil but Store.LogAudit was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Log *models.AuditLog
	}{
		Ctx: ctx,
		Log: log,
	}
	mock.lockLogAudit.Lock()
	mock.calls.LogAudit = append(mock.calls.LogAudit, callInfo)
	mock.lockLogAudit.Unlock()
	return mock.LogAuditFunc(ctx, log)
}

// LogAuditCalls gets all the calls that were made to LogAudit.
// Check the length with:
//
//	len(mockedStore.LogAuditCalls())
func (mock *StoreMock) LogAuditCalls() []struct {
	Ctx context.Context
	Log *models.AuditLog
} {
	var calls []struct {
		Ctx context.Context
		Log *models.AuditLog
	}
	mock.lockLogAudit.RLock()
	calls = mock.calls.LogAudit
	mock.lockLogAudit.RUnlock()
	return calls
}

// SaveBackupMetadata calls SaveBackupMetadataFunc.
func (mock *StoreMock) SaveBackupMetadata(ctx context.Context, meta *models.BackupMetadata) error {
	if mock.SaveBackupMetadataFunc == nil {
		panic("StoreMock.SaveBackupMetadataFunc: method is nil but Store.SaveBackupMetadata was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Meta *models.BackupMetadata
	}{
		Ctx:  ctx,
		Meta: meta,
	}
	mock.lockSaveBackupMetadata.Lock()
	mock.calls.SaveBackupMetadata = append(mock.calls.SaveBackupMetadata, callInfo)
	mock.lockSaveBackupMetadata.Unlock()
	return mock.SaveBackupMetadataFunc(ctx, meta)
}

// SaveBackupMetadataCalls gets all the calls that were made to SaveBackupMetadata.
// Check the length with:
//
//	len(mockedStore.SaveBackupMetadataCalls())
func (mock *StoreMock) SaveBackupMetadataCalls() []struct {
	Ctx  context.Context
	Meta *models.BackupMetadata
} {
	var calls []struct {
		Ctx  context.Context
		Meta *models.BackupMetadata
	}
	mock.lockSaveBackupMetadata.RLock()
	calls = mock.calls.SaveBackupMetadata
	mock.lockSaveBackupMetadata.RUnlock()
	return calls
}

// UpdateCloudFrontStatus calls UpdateCloudFrontStatusFunc.
func (mock *StoreMock) UpdateCloudFrontStatus(ctx context.Context, id string, status string) error {
	if mock.UpdateCloudFrontStatusFunc == nil {
		panic("StoreMock.UpdateCloudFrontStatusFunc: method is nil but Store.UpdateCloudFrontStatus was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		ID     string
		Status string
	}{
		Ctx:    ctx,
		ID:     id,
		Status: status,
	}
	mock.lockUpdateCloudFrontStatus.Lock()
	mock.calls.UpdateCloudFrontStatus = append(mock.calls.UpdateCloudFrontStatus, callInfo)
	mock.lockUpdateCloudFrontStatus.Unlock()
	return mock.UpdateCloudFrontStatusFunc(ctx, id, status)
}

// UpdateCloudFrontStatusCalls gets all the calls that were made to UpdateCloudFrontStatus.
// Check the length with:
//
//	len(mockedStore.UpdateCloudFrontStatusCalls())
func (mock *StoreMock) UpdateCloudFrontStatusCalls() []struct {
	Ctx    context.Context
	ID     string
	Status string
} {
	var calls []struct {
		Ctx    context.Context
		ID     string
		Status string
	}
	mock.lockUpdateCloudFrontStatus.RLock()
	calls = mock.calls.UpdateCloudFrontStatus
	mock.lockUpdateCloudFrontStatus.RUnlock()
	return calls
}

// UpdateUploadApproved calls UpdateUploadApprovedFunc.
func (mock *StoreMock) UpdateUploadApproved(ctx context.Context, id string, reviewedBy string, s3Key string, backupKey string, invID string) error {
	if mock.UpdateUploadApprovedFunc == nil {
		panic("StoreMock.UpdateUploadApprovedFunc: method is nil but Store.UpdateUploadApproved was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		ID         string
		ReviewedBy string
		S3Key      string
		BackupKey  string
		InvID      string
	}{
		Ctx:        ctx,
		ID:         id,
		ReviewedBy: reviewedBy,
		S3Key:      s3Key,
		BackupKey:  backupKey,
		InvID:      invID,
	}
	mock.lockUpdateUploadApproved.Lock()
	mock.calls.UpdateUploadApproved = append(mock.calls.UpdateUploadApproved, callInfo)
	mock.lockUpdateUploadApproved.Unlock()
	return mock.UpdateUploadApprovedFunc(ctx, id, reviewedBy, s3Key, backupKey, invID)
}

// UpdateUploadApprovedCalls gets all the calls that were made to UpdateUploadApproved.
// Check the length with:
//
//	len(mockedStore.UpdateUploadApprovedCalls())
func (mock *StoreMock) UpdateUploadApprovedCalls() []struct {
	Ctx        context.Context
	ID         string
	ReviewedBy string
	S3Key      string
	BackupKey  string
	InvID      string
} {
	var calls []struct {
		Ctx        context.Context
		ID         string
		ReviewedBy string
		S3Key      string
		BackupKey  string
		InvID      string
	}
	mock.lockUpdateUploadApproved.RLock()
	calls = mock.calls.UpdateUploadApproved
	mock.lockUpdateUploadApproved.RUnlock()
	return calls
}

// UpdateUploadRejected calls UpdateUploadRejectedFunc.
func (mock *StoreMock) UpdateUploadRejected(ctx context.Context, id string, reviewedBy string, reason string) error {
	if mock.UpdateUploadRejectedFunc == nil {
		panic("StoreMock.UpdateUploadRejectedFunc: method is nil but Store.UpdateUploadRejected was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		ID         string
		ReviewedBy string
		Reason     string
	}{
		Ctx:        ctx,
		ID:         id,
		ReviewedBy: reviewedBy,
		Reason:     reason,
	}
	mock.lockUpdateUploadRejected.Lock()
	mock.calls.UpdateUploadRejected = append(mock.calls.UpdateUploadRejected, callInfo)
	mock.lockUpdateUploadRejected.Unlock()
	return mock.UpdateUploadRejectedFunc(ctx, id, reviewedBy, reason)
}

// UpdateUploadRejectedCalls gets all the calls that were made to UpdateUploadRejected.
// Check the length with:
//
//	len(mockedStore.UpdateUploadRejectedCalls())
func (mock *StoreMock) UpdateUploadRejectedCalls() []struct {
	Ctx        context.Context
	ID         string
	ReviewedBy string
	Reason     string
} {
	var calls []struct {
		Ctx        context.Context
		ID         string
		ReviewedBy string
		Reason     string
	}
	mock.lockUpdateUploadRejected.RLock()
	calls = mock.calls.UpdateUploadRejected
	mock.lockUpdateUploadRejected.RUnlock()
	return calls
}
